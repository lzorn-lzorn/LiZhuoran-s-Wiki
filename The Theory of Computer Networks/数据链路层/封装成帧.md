所谓封装成帧就是要做以下几点：
- 帧定界，确定一个帧的开始和结束。
- 差值检测，为了差错检测，数据链路层还需要在内部插入一些标记为用于校验
- 为数据链路服务提供信息，插入一些

具体来说，封装成帧有以下四种方案：
1. [[#^780426|字节计数]]
2. [[#^0b9de8|字节填充的标志字节]]，PPP协议就使用了这种方式
3. [[#^c535b1|字节填充的标志比特]]，用于USB协议
4. [[#^b91a64|物理层编码例外法]]

<b>字节计数</b> 的方案就是用一个字段去计数告知这个帧有多少字节，这个方法有一个明显的问题：<u>如果计数的字节因为信道中的干扰变了怎么办</u>。 ^780426

作为其改进，字节填充的标志字节(flag byte)使用一个标志字节(FLAG) 来记录一个帧的开始和结束，连续两个FLAG表示一个帧的结束和另一个帧的开始。这样做也有问题：<u>万一数据中正好有个字节是FALG怎么办</u>(谢希仁的书中用的SOH和EOT)。
![[封装成帧-字节填充EOH冲突-谢.png]]
对于这种情况，提前扫描如果发现FLAG，就在前面加一个ESC(0x1B)字段表示转义，拆帧的时候直接去掉ESC跳过下一个FLAG即可，这种技术叫做字节填充(byte stuffing)
![[封装成帧-字节填充-谢.png]]
（谢希仁的书中用的SOH和EOT，本质上和FLAG是一样的）
<u>新的问题是如果ESC也出现了怎么办</u>，解法是同样用ESC填充，到时候直接删除第一个ESC就行 ^0b9de8

一个字节只有8bits，作为进一步优化，我们希望填充任意多比特来方便后续的校验，这个技术称之为字节填充的标志比特同时也是为了HDLC协议而开发的技术。
字节填充的标志比特就是，使用一个特殊的比特模式0x7E，发送方在遇到连续五个1时自动在后面加一个0，相当于这个多出来的0就是原来的ESC。数据中出现了0x7E(01111110) 就会自动变为 011111010，然后接受方收到之后消除 0x7E，在连续五个1后面跟着的0消除即可。 ^c535b1

不管是填充字符还是比特，数据都会不同程度的变长(取决于撞名的次数)，对于比特填充大约多了12.5%。此时需要回忆在物理层我们有一些冗余的编码(4B/5B)用来保证有足够的比特跳变。换句话说32个信号中16个不会用，那就用这个不会用的16来给帧定界, 这个方法叫做物理层编码例外法。 ^b91a64

以太网和IEEE802.11使用组合了这些方案：有一个72bits的前导码(preamble)然后接一个帧的长度来定位帧的结束