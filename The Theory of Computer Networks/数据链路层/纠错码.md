纠错码有4种不同的方案
- 海明码
- 二进制卷积码
- 里德所罗门码
- 低密度奇偶校验码

书中提到了系统码(systematic code)和线性码(line code)
- 系统码(systematic code)：在编码后的数据中，**原始信息比特**被直接保留在编码后的比特序列中，同时还包含了一些**冗余比特**用于错误检测和纠正。
- 线性码(line code)是一种满足**线性性**的纠错码，即在编码过程中，任意两个合法编码序列的**线性组合**仍然是一个合法的编码序列。线性码可以表示为一个**向量空间**(可以玩矩阵)，其中每个编码序列都是向量空间中的一个向量。

一般情况这两种分类是可以重叠的，很多编码算法都是既是系统码又是线性码，例如海明码，里德-所罗门编码

假设一帧有m个数据位和r个冗余位(用于纠错)，冗余位由数据位计算得到。一个数据块的总长度是 n = m + r，其中n位数据块又称之为码字(codeword)，m/n 表示码率(code rate)

# 海明码(Hamming Code)
Def：海明距离(hamming distance) 两个码字之间不同的位数称为海明距离。也可以将两个码字逐位做异或运算，计算结果1的个数

由于校验码有r位，所以校验码一共有 $2^r$ 种取值，其中有1位要表示正确，所以剩下的 $2^{r}-1$ 要可以表示所有可能位置的错误，所以
$$
2^{r}-1\ge n+r
$$
以1010110为例：
<b>求校验码</b> 
校验码在二进制串中的位置为2的整数幂。剩下的位置为数据。
$$\begin{align}
\begin{matrix}
 p_{1} & p_{2} & m_{3} & p_{4} & m_{5} & m_{6} & m_{7} & p_{8} & m_{9} & m_{10} & m_{11}\\
 p_{1} & p_{2} & 1 & p_{1} & 0 & 1 & 0 & p_{8} & 1 & 1 & 0
\end{matrix}
\end{align}$$

$p_{n}$ 校验所有第n位是1的数据：
$$\begin{align}
\begin{matrix}
\begin{smallmatrix}
 0001 & 0010 & 0011 & 0100 & 0101 & 0110 & 0111 & 1000 & 1001 & 1010 & 1011\\
 p_{1} & p_{2} & 1 & p_{3} & 0 & 1 & 0 & p_{8} & 1 & 1 & 0
\end{smallmatrix}
\end{matrix}
\end{align}$$
所以
- $p_{1}$ 校验：$p_{1},m_{3},m_{5},m_{7},m_{9},m_{11}$
- $p_{2}$ 校验：$p_{2},m_{3},m_{6},m_{7},m_{10},m_{11}$
- $p_{3}$ 校验：$p_{3},m_{4},m_{5},m_{6}$

这样依次类推，$p_{n}$ 的值使得所有校验位(包括自己)异或为1
Eg: $p_{1}\oplus m_{3}\oplus m_{5}\oplus m_{7} \oplus m_{9} \oplus m_{11}=1$ 解出 $p_{1}$
所以1010110海明码就是01110100110

<b>校验过程</b>: 如果某一位错误了，校验码会直接给出错误位置
例如：1010110 → 1110110 则海明码变为01110100110 → 01111100110
此时只要在按照上面的流程将 例如: $p_{1}\oplus m_{3}\oplus m_{5}\oplus m_{7} \oplus m_{9} \oplus m_{11}=p'_{1}$ 算一遍，将所有的结果排一次就能得到错误的位置，要从右往左排, 即 $p'_{4}p'_{3}p'_{2}p'_{1}$ 将这个位置的数字反转即可。
更加一般的算法, 见Wiki：[汉明码](https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E7%A0%81) 
Wiki 按照奇偶校验矩阵的方式给出了一般的算法

<b>性质</b>：海明码其实在网络纠错中还是不够强大，只能纠错1位，但是可以用于内存的纠错中

# 卷积码（Convolutional Code）
在实际的网络中，我们更多使用卷积码
[卷积码编码和Viterbi解码](https://www.bilibili.com/video/BV16B4y1M7Q4/?spm_id_from=888.80997.embed_other.whitelist&t=5.271576&bvid=BV16B4y1M7Q4&vd_source=75cdf78dd1707c1077825f0501243c43)
[卷积码 WIKI](https://zh.wikipedia.org/zh-hans/%E5%8D%B7%E7%A7%AF%E7%A0%81)
Def: 卷积码用（n，k，L）表示，码率为R，其中
- n为输出码字
- k为输入的比特信息
- L为约束长度，也称为记忆深度
- R表示为R = k/n

卷积码是一种有记忆的纠错码，编码规则是将k个信息比特编码形成n个比特，编码后的n个码元不但与当前输入的k个信息有关，仍与之前的L-1组的信息有关，其结构如下图所示，
![[卷积码.excalidraw|700]]
注意：
1. 图中的移位操作具体做几次, 称之为记忆深度，也就是上面Def的L, 上图中的L正好等于2k，只是示意而已，真是情况是 L≤10 
2. 图中G，是生成向量，也就是到底选哪几个位置做异或运算。这个G不是随便选的，是确定的只要去查就行。
3. 至于具体选几个 G，也是人为设定的，根据2. 应该也能查到


<b>状态图表示法</b>: 所谓状态图表示法，就是对应状态机模型画出状态机的转移函数。例如上图中有G1,G2两个输出，则状态转移函数就有4个状态 00, 01, 11, 10 然后根据输入0,1 和输出1, 0画出状态机的状态转移函数, 一下视频中有具体例子
[卷积码编码和Viterbi解码, 时间点: 10:05](https://www.bilibili.com/video/BV16B4y1M7Q4/?spm_id_from=888.80997.embed_other.whitelist&t=5.271576&bvid=BV16B4y1M7Q4&vd_source=75cdf78dd1707c1077825f0501243c43)

<b>网格图法</b>：网格图法是在状态图法的基础上增加了时间的信息, 以表格的形式呈现。
[卷积码编码和Viterbi解码, 时间点: 14:40](https://www.bilibili.com/video/BV16B4y1M7Q4/?spm_id_from=888.80997.embed_other.whitelist&t=5.271576&bvid=BV16B4y1M7Q4&vd_source=75cdf78dd1707c1077825f0501243c43)
[卷积码基本原理 - 知乎](https://zhuanlan.zhihu.com/p/354943239)
解码算法-Viterbi解码：该解码方式是一种动态规划算法去寻找Viterbi路径使用了隐式马尔科夫模型(HMM)，具体算法：[维特比算法 WIKI](https://zh.wikipedia.org/wiki/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95)

基于Viterbi解码还有两种方式
- 硬判别解码(hard-decision decoding): 把收到的电压直接映射为1或0，然后给译码器去译码
- 软判别解码(soft-decision decoding): 在译码之前不要转换为1或0，而是用更多比特去表示电压，然后再去译码，这样会更准一点。

在Viterbi算法执行的过程中就已经完成了纠错。原因是：
在卷积编码过程中，输入比特流会通过移位寄存器和生成多项式的组合，生成多个输出比特。由于每个输出比特不仅依赖于当前输入比特，还依赖于前 L−1 个比特（约束长度），因此输出比特流中含有输入比特序列的冗余信息。
找到最优路径意味着找到与接收到的比特流最匹配的路径。这个过程等同于**最大似然估计**，也就是选择使得接收比特流出现的可能性最大的输入比特序列。
由于卷积码具有冗余信息，如果某个比特因为噪声而被错误翻转，这个错误会导致该路径与接收到的比特流的匹配度降低。通过考察整条路径的匹配情况，维特比算法可以发现包含错误的路径匹配度较低，因此倾向于选择包含真实输入序列的路径。
假设有一条错误路径，与正确路径在某个比特上不同。由于卷积码的冗余特性，这个单独的比特错误会导致随后的输出比特流与接收比特流逐渐偏离。随着路径不断延伸，错误路径的**累积误差**会不断增加，从而使解码器最终放弃这条路径。
# 里德-所罗门码(Reed-Solomon Code)


# 低密度奇偶校验码(Low-Density Parity Check, LDPC)
