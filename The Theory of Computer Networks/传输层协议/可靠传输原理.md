# 构造可靠传输协议 
构造的基本思路是: 开始假设一个完美的信道，再一点一点加噪声, 直到这个信道变成现实的信道，最后再优化性能。
现实中的信道往往有两个特点：
1. 比特流会在传输的过程中发生改变
2. 数据报可能由于各种情况失踪或者迟到
## 基于完全可靠信道的传输协议
如果信道是完全可靠的话, 就几乎不需要设计协议。见以下自动机
![[可靠传输机制自动机1.png]]
[记号说明]: 横线上是发生的事件, 横线下是发生改事件后采取的措施
`rdt_sent (data)` 表示收到了高层来的数据
`packet = make_pkt(data)` 将数据分包 (具体操作)
`udt_send (packet)` 将数据报分组发送

同样的, 在接收端, 收到一个来自下层的数据 `rdt_rcv (data)` 
从分组中取出数据 `extract (packet, data)`; 然后发送给上层 `deliver_data (data)`

## 基于有比特差错信道的可靠数据传输
在信道出现比特差错时, 此时我们只需要提供两个机制: 
- 差错检测：这是由数据链路层提供的服务 [[差错控制]]
- 接收方反馈: 使用 ACK/NAK (重传/不用重传)来告知发送端是否需要重新传输

然后重新传输即可.

![[可靠传输机制自动机2.png]]
如果 ACK/NAK 分组出现问题, 在几乎所有的协议中都使用了分组来解决这个问题，自动机如下：
![[可靠传输机制自动机3.png]]
使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接收的分组发送一个肯定确认。如果收到受损的分组 .则接收方将发送一个再定确认, 如果不发送 NAK ，而是对上次正确接收的分组发送一个 ACK ，我们也能实现与NAK 一样的效果。发送方接收到对同一个分组的两个 ACK(即接收冗余 ACK( duplicate ACK))后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。

![[可靠传输机制自动机4.png]]
同时, 在有比特差错信道上实现的一个无 NAK 的可靠数据传输协议
这两个版本之间的细微变化在于，接收方此时必须包括由一个 ACK 报文所确
认的分组序号 (这可以通过在接收方 DFS 中，在 make_pkt0 中包括参数 ACK0 或ACK1 来实现) ，发送方此时必须检查接收到的 ACK 报文中被确认的分组序号 (这可通过在发送方 DFS 中，在 isACK0 中包括参数 0 或 1来实现)。本质上就是合并同类项


## 基于有比特差错信道和丢包机制的可靠数据传输
对于带有丢包机制的信道, 最常见的方式就是设置一个计数器
![[可靠传输机制自动机5.png]]


![[等待停止协议时间图.png]]

## 基于流水线的优化方法
在一个实际的信道中，两个端之间有传输的延迟, 也就是往返的时间 RTT, 已经信息传输的速率 R 和分组的长度 L . 所以发送一个实际分组进入链路实际需要 
$$
T_{D}=\frac{L}{R}
$$
定义信道的利用率为：发送方实际忙于发送数据的时间与整个发生时间之比
$$
U=\frac{L/R}{L/R+\text{RTT}+T_{A}}
$$
![[流水线的停止等待协议.png]] 
实际上, ACK的发生时间非常短, 往往就忽略不计了
这种情况的报文或者ACK丢失就是以一个序号范围内丢失。面对这种情况会有两种差错处理的方法

# 后退N帧协议(GBN)
后退N帧协议的思路非常简单：收到了序号为1,2,3, k的帧，但是k+1号丢失了, 那么后续收到的帧都不要, 只等k+1号重发
![[后退N帧协议自动机.png]]
其中base 是基序号, 也就是滑动窗口的第一帧; nextseqnum是下一帧的序号
# 选择重传协议(SR)
为了进一步改善GBN的性能问题, 使用滑动窗口来等告诉发送方不用传输已经收到的帧
![[SR选择重传协议.png]]
